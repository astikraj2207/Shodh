#include <bits/stdc++.h>
using namespace std;

#define M1 1000000007
#define M2 998244353
#define INF 1e18
#define ll long long
#define pll pair<ll,ll>
#define REP(i,a,b) for(ll i=a;i<b;i++)
#define REPR(i,a,b) for(ll i=b-1;i>=a;i--)
#define forr(i,n) for(ll i=0;i<n;i++)
#define F first
#define S second
#define pb push_back
#define DB pop_back
#define mp make_pair
#define MT make_tuple
#define V(a) vector<a>
#define vi vector<ll>
#define endl '\n'
#define ce(ele) cout<<ele<<' '
#define cs(ele) cout<<ele<<'\n'
#define CASE(t) ll t; cin>>t; while(t--)
/********************************************************************/
const double pi = 3.1415926535;
/********************************************************************/
//FAST IO//
void FAST() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
}

vector <int> arr(100001);
vector <int> tree(400005);
vector <int> lazy(400005);
void Build(int index, int ls, int rs)
{
  if (ls==rs)
  {
    tree[index]= arr[ls];
  }
  else
  {
    int mid=(ls+rs)/2;
    Build(2*index, ls, mid);
    Build(2*index+1, mid+1, rs);

    tree[index]=tree[2*index] + tree[2*index+1];
  }
}

int Query(int l, int r,int idx, int cl, int cr)
{
  if (lazy[idx]!=0)
  {
    tree[idx] += lazy[idx]*(cr-cl+1);
    if (cl!=cr)
    { lazy[idx*2] += lazy[idx]; lazy[2*idx +1] += lazy[idx]; }
    lazy[idx]=0;
  }

  if (l<=cl && r>=cr)
  {
    return tree[idx];
  }
  else if (r<cl || l>cr)
  {
    return 0;
  }
  else
  {
    int mid=(cl+cr)/2;
    int a= Query(l, r, 2*idx, cl, mid) ;
   int b= Query(l, r, 2*idx+1, mid+1, cr) ;
   return a+b;
  }
}

void ptUpdate(int index, int ls, int rs, int ch, int val)
{
  if (ls==rs && ls==ch)
  {
    tree[index]=val;
  }
  else if (ls<=ch && ch<=rs)
  {
    int mid=(ls+rs)/2;
    ptUpdate(2*index, ls, mid, ch, val);
    ptUpdate(2*index+1, mid+1, rs, ch, val);

    tree[index]=tree[2*index]+ tree[2*index+1];
  }
}

void lazyUpdate(int l, int r,int idx, int cl, int cr, int val)
{
   if (lazy[idx]!=0)
  {
    tree[idx] += lazy[idx]*(cr-cl+1);
    if (cl!=cr)
    { lazy[idx*2] += lazy[idx]; lazy[2*idx +1] += lazy[idx]; }
    lazy[idx]=0;
  }

  if (l<=cl && r>=cr)
  {
   
    // lazy[idx]+=val; would store lazy for that node itself...instead, increment her and pass on lazy
    tree[idx] += val*(cr-cl+1);
    if (cl!=cr)
    { lazy[idx*2] += val; lazy[2*idx +1] += val; }
    return;

  }
  else if (r<cl || l>cr)
  {
    return;
  }
  else
  {
    int mid=(cl+cr)/2;
    lazyUpdate(l, r, 2*idx, cl, mid, val) ;
    lazyUpdate(l, r, 2*idx+1, mid+1, cr, val) ;

    tree[idx]=tree[2*idx]+ tree[2*idx+1];
  }
}
/********************************************************************/
int main() {
	FAST();

	CASE(t) {

    tree.clear();
    lazy.clear();

    int n, c;
    cin>>n>>c;
    forr(i,c)
    {
      int b; cin>>b;
      if (b==0)
      {
        int p,q,val; cin>>p>>q>>val;
        lazyUpdate(p,q, 1, 1, n, val);
      }
      else 
      {
        int p,q; cin>>p>>q;
        int ans= Query(p, q, 1, 1, n);
        cout<<ans<<endl;
      }
    }

	}


	return 0;
}